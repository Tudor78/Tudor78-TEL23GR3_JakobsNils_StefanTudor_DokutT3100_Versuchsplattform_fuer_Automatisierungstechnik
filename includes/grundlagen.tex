\chapter{Grundlagen und Stand der Technik}
\label{chap:grundlagen und stand der technik}
Für die vorliegende Arbeit sind Kenntnisse in den Bereichen Rapid Control Prototyping, modellbasierte Entwicklung mit Matlab und Simulink, Inertialsensorik sowie Lageschätzung mittels Sensorfusion erforderlich, weshalb in den folgenden Kapiteln die hierfür relevanten Grundlagen und der Stand der Technik dargestellt werden.


\section{Rapid Control Prototyping}
\label{sec:Rapid Control Prototyping}
Rapid Control Prototyping bezeichnet einen Ansatz zur schnellen Entwicklung und Erprobung von Regelungsstrategien an Anwendungen oder Laboraufbauten. Charakteristisch ist, dass der Entwurf nicht primär durch eine manuelle Implementierung in textbasierten Programmiersprachen erfolgt, sondern durch die Modellierung als grafisches Blockdiagramm, das anschließend auf eine Zielplattform übertragen wird. Ziel ist es, den Übergang vom Entwurf zur lauffähigen Implementierung zu verkürzen, indem aus dem grafischen Modell automatisch ausführbarer Code erzeugt und auf der Zielhardware ausgeführt wird. Dadurch werden kurze Iterationszyklen unterstützt, weil Entwurf, Test und Parametrierung in engem Zusammenhang durchgeführt werden können \parencite{HoyosGutierrez2023RCPReview}.

Für die praktische Umsetzung wird RCP typischerweise als Kombination aus Zielhardware und Entwicklungssoftware verstanden. Die Zielhardware umfasst eine Recheneinheit mit Speicher sowie Ein und Ausgängen und kann je nach Anwendung als \ac{PC}, Mikrocontroller oder programmierbare Logik realisiert sein. Die Entwicklungssoftware stellt eine grafische Modellierungsumgebung bereit, in der der Regelalgorithmus als Blockdiagramm beschrieben wird und aus der anschließend ausführbarer Code für die Zielplattform generiert wird \parencite{HoyosGutierrez2023RCPReview}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\linewidth]{V-Modell_RCP.png}
  \caption[V-Modell zur Einordnung von Rapid Control Prototyping]{V-Modell zur Einordnung des Rapid Control Prototyping \parencite{HoyosGutierrez2023RCPReview}.}
  \label{fig:V-Modell_RCP}
\end{figure}

Die Abbildung ~\ref{fig:V-Modell_RCP} ordnet den Einsatz von RCP in einen V Modellentwicklungsprozess ein. Die linke Seite beschreibt die Schritte von \emph{Design, Modelling and Simulation} bis zur \emph{Validation with RCP}. In dieser Phase wird der Reglerentwurf im Modell erstellt, simulativ bewertet und für die Ausführung vorbereitet. Der Übergang zur Zielplattform erfolgt im Schritt \emph{Target Code on Hardware}, bei dem der aus dem Modell abgeleitete Code auf der Hardware ausgeführt wird. Die rechte Seite des V Modells umfasst die Schritte \emph{Verification with SIL or HIL} sowie \emph{Integration and Test}. Dabei werden Implementierung und Systemverhalten anhand geeigneter Testumgebungen geprüft, wobei SIL und HIL als etablierte Testformen zur schrittweisen Absicherung dienen. Die in der Abbildung markierte Verifikationsphase adressiert die Frage, ob die Implementierung die spezifizierten Anforderungen korrekt erfüllt. Die Validierungsphase adressiert die Frage, ob die Lösung im Anwendungskontext den beabsichtigten Nutzen liefert und die vorgesehenen Funktionen in der Zielumgebung erfüllt. RCP unterstützt diesen Ablauf, indem Modell, Simulation und Ausführung auf der Zielhardware eng gekoppelt sind und Anpassungen am Entwurf zeitnah am realen System überprüft werden können \parencite{HoyosGutierrez2023RCPReview}.

In vielen Anwendungen bildet Matlab in Verbindung mit Simulink die zentrale Entwicklungsumgebung, da Reglerentwurf, Simulation und Implementierung über einen konsistenten Modellkern verbunden werden können \parencite{Werth2020LowCostRCP,Fang2009LowCostDSPRCP}. Die Funktionsweise der modellbasierten Entwicklung mit Matlab und Simulink wird in Abschnitt~\ref{sec:Modellbasierte Entwicklung mit Matlab/Simulink} erläutert.
\newpage

\section{Modellbasierte Entwicklung mit Matlab/Simulink}
\label{sec:Modellbasierte Entwicklung mit Matlab/Simulink}
Bei der modellbasierten Entwicklung in Matlab und Simulink steht ein ausführbares Systemmodell im Mittelpunkt des Engineeringprozesses. Anstatt frühzeitig eine reine Softwareimplementierung zu erstellen, wird das Systemverhalten zunächst durch Modelle beschrieben, die sowohl für Analysen als auch für Simulationen genutzt werden. Matlab wird dabei vor allem für Berechnungen, Auswertungen, Parametrierungen und Visualisierungen eingesetzt. Simulink ergänzt dies durch eine grafische Blockdiagrammumgebung, mit der dynamische Systeme strukturiert aufgebaut und simuliert werden können. Für physikalische Teilbereiche wie mechanische oder elektrische Komponenten lässt sich Simscape verwenden, um domänenübergreifende Modelle konsistent in einem gemeinsamen Rahmen zu formulieren.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\linewidth]{Workflow_MBD.png}
  \caption[Zentraler Workflow der modellbasierten Entwicklung]{Zentraler Workflow der modellbasierten Entwicklung\parencite{Aarenstrup2025ManagingMBD}.}
  \label{fig:workflow-mbd}
\end{figure}

Die Abbildung~\ref{fig:workflow-mbd} veranschaulicht den Grundgedanken der modellbasierten Entwicklung, bei der ein ausführbares Modell als zentrales Entwicklungsartefakt den gesamten Engineeringprozess strukturiert \parencite{Aarenstrup2025ManagingMBD}. Im Mittelpunkt steht das \emph{Model}, in dem sowohl die Anforderungen (\emph{Requirements}) als auch Ergebnisse aus Voruntersuchungen und Domänenwissen (\emph{Research}) zusammengeführt werden. Das Modell dient als gemeinsame Grundlage, aus der sich das Systemverhalten, die Schnittstellen und wichtige Entwurfsentscheidungen ableiten lassen, ohne dass zu Beginn bereits eine separate Implementierung als Textcode im Fokus steht. Simulink unterstützt dies durch die grafische Modellierung dynamischer Systeme als Blockdiagramm, während Matlab für Berechnungen, Auswertungen, Parametrierungen und Visualisierungen genutzt wird. Für physikalische Teilmodelle kann Simscape eingesetzt werden, um mechanische, elektrische oder andere Domänen im gleichen Modell abzubilden.

Die in der Abbildung umlaufenden Rückkopplungen verdeutlichen, dass die Modellentwicklung nicht linear erfolgt, sondern iterativ organisiert ist. Der Zyklus \emph{Modeling and simulation} steht für das wiederholte Aufbauen und Simulieren des Systems, um das zeitliche Verhalten zu analysieren und zentrale Eigenschaften wie Stabilität und Regelgüte unter variierenden Betriebsbedingungen zu bewerten. Die dabei gewonnenen Ergebnisse fließen in die Modellanpassung und Parametrierung zurück, wodurch die Modellgüte schrittweise erhöht wird. Matlab wird in dieser Phase insbesondere zur systematischen Auswertung von Simulationsergebnissen eingesetzt, etwa für Parameterstudien, Kennwertberechnungen und die grafische Darstellung relevanter Signale.

Der Kreis \emph{Rapid prototyping} beschreibt den frühen Übergang vom Modell zur lauffähigen Ausführung, um Entwurfsentscheidungen unter realitätsnäheren Randbedingungen zu prüfen. Ein zentraler Baustein ist hierbei die Codegenerierung aus dem Simulink Modell, durch die automatisch ausführbarer Code erzeugt wird, der auf Zielhardware wie einem Mikrocontroller, \ac{DSP} oder \ac{FPGA} eingesetzt werden kann. Die Abbildung verdeutlicht damit, dass Implementierungsergebnisse nicht als unabhängige Parallelentwicklung entstehen, sondern als abgeleitete Artefakte aus dem zentralen Modell, wodurch die Konsistenz zwischen Entwurf und Ausführung erhöht wird.

Der dritte Kreis \emph{Continuous test and verification} betont, dass Verifikation und Tests fortlaufend in den Entwicklungsprozess integriert sind. In diesem Kontext werden gestufte Testmethoden eingesetzt, um die Anforderungen systematisch abzusichern. Bei \ac{SIL} wird das Regelungssystem gemeinsam mit der Strecke in einer simulierten Umgebung ausgeführt, während bei \ac{HIL} eine reale Steuerungshardware mit einem in Echtzeit berechneten Streckenmodell gekoppelt wird. Diese Vorgehensweisen ermöglichen eine frühe Prüfung gegen Anforderungen und unterstützen die Identifikation von Abweichungen, bevor ein vollständiger Versuchsaufbau oder ein finales Gesamtsystem vorliegt.

Der nach unten gerichtete Pfeil \emph{Generation of outputs} fasst zusammen, welche Ergebnisse aus dem Modell abgeleitet werden. Dazu zählen insbesondere Produktionscode, Berichte sowie Nachweisartefakte für eine spätere Dokumentation und gegebenenfalls Zertifizierung. Abbildung~\ref{fig:workflow-mbd} macht damit deutlich, dass modellbasierte Entwicklung in Matlab und Simulink nicht nur die Simulation unterstützt, sondern einen durchgängigen Ablauf von der Anforderungsableitung über die iterative Modellentwicklung bis zur Implementierung und Absicherung bereitstellt. Für die vorliegende Arbeit ist dieser Ansatz zentral, da die Versuchsplattform und die Algorithmen in einer einheitlichen Modellbasis entwickelt, prototypisch auf Zielhardware ausgeführt und anschließend experimentell validiert werden.


\section{Inertialsensorik}
\label{sec:Inertialsensorik}
Eine Inertialmesseinheit (\ac{IMU}) ist ein Sensorsystem zur Erfassung von Bewegungen eines Körpers im Raum. Sie kombiniert Beschleunigungssensoren, die die spezifische Kraft messen, mit Drehratensensoren, die die Winkelgeschwindigkeit erfassen. Üblich ist eine Ausführung mit jeweils drei Sensoren pro Messgröße, deren empfindliche Achsen orthogonal angeordnet sind, sodass dreidimensionale Messungen in einem körperfesten Koordinatensystem bereitgestellt werden können \parencite{Groves2015InertialSensorsTutorial}.

Die Messgrößen einer \ac{IMU} werden typischerweise als zeitdiskrete Signale ausgegeben. Dazu versorgt die \ac{IMU} die Sensoren, digitalisiert deren Ausgangssignale und überträgt die Messwerte über eine Datenschnittstelle. Die Ausgabe erfolgt häufig mit hohen Datenraten im Bereich von mehreren hundert Hertz, was insbesondere für dynamische Systeme in Regelungs und Navigationsaufgaben relevant ist \parencite{Groves2015InertialSensorsTutorial}. Inhaltlich ist zu beachten, dass Beschleunigungssensoren nicht direkt die translatorische Beschleunigung im Sinne der Kinematik liefern, sondern die spezifische Kraft. Diese entspricht der durch Trägheit verursachten Beschleunigung relativ zu einem frei fallenden Bezug und enthält damit die Wirkung der Gravitation in der Messinterpretation \parencite{Groves2015InertialSensorsTutorial}.

Aus den \ac{IMU} Messungen kann mittels inertialer Navigation eine Schätzung von Position, Geschwindigkeit und Orientierung abgeleitet werden. Das Grundprinzip besteht darin, die gemessenen Winkelgeschwindigkeiten zur Aktualisierung der Orientierung zu integrieren. Mit der so bestimmten Orientierung lassen sich die gemessenen spezifischen Kräfte in ein erdfestes oder navigationsbezogenes Koordinatensystem transformieren. Nach Berücksichtigung eines Gravitationsmodells wird daraus die translatorische Beschleunigung bestimmt, die wiederum zu Geschwindigkeit und Position integriert wird \parencite{Groves2015InertialSensorsTutorial}. Dieses Vorgehen wird in der Praxis als Strapdown Inertialnavigation umgesetzt, bei der eine \ac{IMU} mit einem Navigationsprozessor zusammenwirkt, der die Navigationslösung aus spezifischer Kraft und Winkelgeschwindigkeit fortschreibt \parencite{Groves2015InertialSensorsTutorial}.

Ein wesentliches Merkmal inertialer Systeme ist die Fehlerfortpflanzung durch Integration. Bereits kleine konstante Sensorabweichungen, etwa Bias, Skalierungsfehler oder Achsfehlstellungen, führen über die Zeit zu wachsenden Fehlern in Geschwindigkeit, Orientierung und Position. Das Tutorial beschreibt typische Biaswerte für unterschiedliche Qualitätsklassen von \ac{IMU} Systemen und zeigt, dass insbesondere bei niedrigeren Sensorgüten deutliche Drift auftreten kann \parencite{Groves2015InertialSensorsTutorial}. Für taktische Sensorik wird beispielsweise beschrieben, dass sich Positionsfehler im Bereich mehrerer Kilometer innerhalb etwa einer Stunde aufbauen können, wenn entsprechende Fehleranteile nicht kompensiert werden \parencite{Groves2015InertialSensorsTutorial}. Daraus folgt, dass eine reine inertiale Lösung für längere Zeiträume meist nur begrenzt geeignet ist, sofern keine zusätzlichen Informationsquellen zur Korrektur verfügbar sind.

Zur Begrenzung der Drift werden \ac{IMU} basierte Lösungen häufig mit weiteren Sensorsystemen kombiniert. Das Tutorial beschreibt hierfür integrierte Navigationsarchitekturen, bei denen ein Schätzalgorithmus, typischerweise ein Kalmanfilter, die inertiale Lösung mit einem Hilfssystem wie \ac{GNSS} vergleicht und daraus Korrekturen für Position, Geschwindigkeit und Orientierung ableitet. Die Kopplung ist so ausgelegt, dass auch bei zeitweilig fehlenden Hilfsmessungen weiterhin eine Navigationslösung vorliegt, während bei verfügbaren Messungen eine geschlossene Rückführung zur Fehlerreduktion erfolgt \parencite{Groves2015InertialSensorsTutorial}. Für Anwendungen mit wiederkehrenden Stillstandsphasen oder Bewegungsrestriktionen können zusätzlich sogenannte Nullupdates oder Bewegungskonstraints genutzt werden, um den Zustand zu stabilisieren und Sensorfehler indirekt zu kalibrieren \parencite{Groves2015InertialSensorsTutorial}.


\newpage
\section{Quaternionen und Euler-Winkel}
\label{sec:Quaternionen und Euler-Winkel}
"Lorem ipsum" 

\newpage
\section{Lageschätzung mittels Sensorfusion}
\label{sec:Lageschätzung mittels Sensorfusion}
"Lorem ipsum"
\newpage